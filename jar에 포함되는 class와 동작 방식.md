## jar에 포함되는 class는 어떤것들일까?
빌드하면 `target/classes` 또는 `build/classes`에 컴파일된 `.class`파일로 존재한다.  
jar안에서는 `BOOT-INF/classes` 또는 루트에 `.class` 파일들이 위치한다.  
(물론 resources에 있는 .properties나 .yml도 jar에 포함됨)


## 어떤 파일이 `.class`로 빌드될까?
1. 내가 작성한 POJO 클래스는 .class로 빌드된다.  
   자바 표준 라이브러리는 JDK에 .class로 이미 존재하는 상태이기 때문에 따로 빌드하지 않고, 런타임에 Linking만 진행한다.
  > **java8까지는 표준 라이브러리는 JRE에 위치한다.**
  > **하지만 java9부터는 JDK가 JRE 역할을 겸하기 때문에 JDK 하위에 표준 라이브러리가 위치함**

2. gradle을 통해 추가하는 서드파티 라이브러리 또한 이미 .class로 존재하기 때문에 빌드 시 그대로 JAR 안에 포함시키거나 추가적인 jar파일로 배포됨


## 그러면 System.out.println의 System 클래스처럼 내장 클래스는?
위에서 말했듯이 따로 빌드되지는 않고, **JDK**에 내장된채로 런타임 환경에서 동적으로 Linking된다.


## 그래서 Linking이 뭔데? 먼소리임?
일단 Java가 아닌 일반적인 Computer Science에서의 Linking은 **여러 파일을 하나로 합쳐주는 것이다.**  
그러나 JVM에서의 링킹 과정은 파일을 하나로 합치지는 않는다.

우리가 List 클래스를 사용하려면 `java.util`이라는 의존성을 import 해야 한다.
**JVM은 이러한 의존성을 전부 `심볼릭 참조` 형태로 표시만 해놓는다.

실제 런타임에서 코드를 실행하다가 심볼릭 참조를 만나면 다음과 같이 동작한다.
- 해당 심볼릭 참조를 처음으로 만났다면 **로딩 단계**를 거친다
	1. 클래스로더가 해당하는 .class를 찾는다.
	2. **.class를 메타데이터로 변환하여 Method 영역에 저장한다.**
- **링크 단계**
	1. 바이트코드 validation
	2. static필드의 메모리 할당 등을 진행
	3. **심볼릭 참조를 Method 영역에 적재된 해당 클래스의 메모리 주소로 치환**

즉, JVM에서는 런타임에서 코드를 읽으면서 실제로 필요한 순간에만 심볼릭 참조를 통해 메모리에 해당 클래스를 적재한다.
그 전에는 디스크에 .class로 존재할뿐이다.


## List 클래스는 jar에 .class로 컴파일되어 들어가있을까?
ㄴㄴ 아님. List와 같은 표준 라이브러리는 JDK 내부에 내장되어 있다.  
그렇기 때문에 만약 JDK버전을 올리면 표준 라이브러리의 동작 방식이 달라질 수 있으므로 성능 차이가 발생하거나 버그를 야기할 수 있다.
개발자들이 버전 올리는걸 무서워하는 이유 중 하나...


## 그럼 본론으로 돌아가서, jar파일에는 어떤것들이 .class로 들어갈까?
스프링부트 프로젝트 기준으로 설명하자면 다음과 같은 클래스들이 jar에 포함된다.
- 내가 직접 짠 클래스 (위에서 말했듯이 얘만 컴파일시점에 빌드된다)
- springboot와 같이 pom.xml이나 gradle에 추가되는 외부 종속성 라이브러리들
